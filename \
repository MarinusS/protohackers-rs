use std::{collections::HashMap, net::SocketAddr, time::Duration};

use tokio::{io, net::UdpSocket, sync::mpsc, task::JoinHandle};

type SessionToken = u32;

#[derive(Clone)]
enum Message<'a> {
    Connect {
        token: SessionToken,
    },
    Data {
        token: SessionToken,
        pos: u64,
        data: &'a [u8],
    },
}

struct Session {
    token: SessionToken,
}

pub struct LRCPListener {
    new_session_chan_rx: mpsc::Receiver<SessionToken>,
    udp_listener_task: JoinHandle<()>,
}

impl LRCPListener {
    pub async fn new(ip_addr: std::net::Ipv4Addr, port: u16) -> Result<LRCPListener, io::Error> {
        let socket = UdpSocket::bind((ip_addr, port)).await?;
        let (_new_session_chan_tx, new_session_chan_rx) = mpsc::channel(64);
        let (new_message_chan_tx, new_message_chan_rx) = mpsc::channel(64);

        let udp_listener_task = tokio::spawn(udp_listener(socket, new_message_chan_tx));

        Ok(LRCPListener {
            new_session_chan_rx,
            udp_listener_task,
        })
    }
}

async fn udp_listener(socket: UdpSocket, new_message_chan_tx: mpsc::Sender<Message<'_>>) {
    let mut buf = [0; 1024];
    loop {
        let (len, addr) = socket.recv_from(&mut buf).await.unwrap();
        let msg = parse_datagram(&buf[..len]);
        if let Some(msg) = msg {
            new_message_chan_tx.send(msg).await;
        }
    }
}

fn parse_datagram(datagram: &[u8]) -> Option<Message> {
    if !(datagram.first() == Some(&b'/') && datagram.last() == Some(&b'/')) {
        return None;
    }

    let datagram = &datagram[1..datagram.len() - 1];
    let mut values = datagram.split(|&x| x == b'/');

    match values.next() {
        Some(b"connect") => Some(Message::Connect {
            token: str::parse::<u32>(std::str::from_utf8(values.next()?).ok()?)
                .ok()?
                .clone(),
        }),
        _ => None,
    }
}
